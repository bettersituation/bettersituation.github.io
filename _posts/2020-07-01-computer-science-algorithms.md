---
layout: post
topic: computer-science
title: 알고리즘
---

자료구조를 학습한 후 알고리즘을 공부하리라 다짐했었다.  
6 월에 자료구조를 마친 후 이제 알고리즘을 학습해보려고 한다.  
알고리즘 역시 참고할 수 있는 자료가 많고 그 컨셉이 다양한데,  
각 책마다 문제풀이에 집중하거나 이론에 집중하는 등 그 컨셉이 다르다.  


여자친구에게 의견을 구해보니 일단 이론적인 것을 학습한 후  
문제풀이는 리트코드 등의 온라인 사이트를 이용하는 것이 좋을 것 같다 하여 그렇게 하기로 했다.  

읽을 책은 한빛 교재 시리즈 중 하나인 "쉽게 배우는 알고리즘 - 관계 중심의 사고법" 이라는 책이다.  
목차를 대충대충 살펴보니 자료구조와 겹치는 부분이 많았다.  
사실 상 자료구조의 심화버젼이라고 해도 될 정도였다.  

정리할 내용이 많을 듯 싶다. 운영체제 정리와 다르게 그림, 의사코드 및 수식 등이 많이 등장할 듯 하다.  
책에서 소개하는 알고리즘에 대해 실제 코드를 구현해보면 좋겠지만 그렇게 하면 너무 오래 걸릴 듯 하다..  
그러므로 운영체제와 마찬가지로 챕터 별로 중요한 내용만 추려서 정리할 것이다.  

---

### 1. 알고리즘 설계와 분석의 기초

- 알고리즘의 중요성과 표기법에 대해 다루는 챕터
- 표기법 및 그 뜻은 아래와 같다.

$$
\text{1.} \; O(f(x)) = \{ g : \lim_{n \rightarrow \infty} \frac{g(x)}{f(x)} < \infty \} \quad \text{(점근적 상한)} \\
\text{2.} \; \Omega(f(x)) =  \{ g : \lim_{n \rightarrow \infty} \frac{f(x)}{g(x)} < \infty \} \quad \text{(점근적 하한)} \\
\text{3.} \; \Theta(f(x)) = O(f(x)) \cap \Omega(f(x)) \\
\text{4.} \; o(f(x)) = \{ g : \lim_{n \rightarrow \infty} \frac{g(x)}{f(x)} = 0 \} \quad \text{(여유있는 상한)} \\
\text{5.} \; \omega(f(x)) =  \{ g : \lim_{n \rightarrow \infty} \frac{f(x)}{g(x)} = 0 \} \quad \text{(여유있는 하한)} \\
$$

- 여담으로 보통 빅-오를 세타로 표기하는 경우가 많은 듯..

---

### 2. 점화식과 점근적 복잡도 분석

- 점화식으로 표현된 시간 복잡도를 단일식으로 표현하는 방법을 배운다.  
- 반복 대치, 추정 후 증명, 마스터 정리 세 가지 방법이 있다.  
- 반복 대치는 식을 반복하여 계산하는 방법이다. 예를 들어 T(n) <= T(n/2) + n 이라고 하면 
T(n) <= T(n/2) + n <= n + n/2 + T(n/4) <= ... = O(n * log2 n]) 이 성립한다.  
- 추정 후 증명은 말 그대로 추정 후 증명하는 방법이다. 수학적 귀납법 등이 증명에 사용된다.  
- 마스터 정리는 T(n) = aT(n/b) + f(n) 의 형식으로 표현되는 재귀식의 복잡도를 알 수 있는 정리이다.  
- n^(logb a) = h(n) 이라고 하면
- h(n) 이 더 복잡하면 h(n) 이, f(n) 이 더 복잡하면 f(n) 이 수행시간을, 똑같으면 logn * h(n) (또는 동일하게 f(n)) 이 수행시간을 지배한다는 정리이다.

---

### 3. 정렬

- 선택정렬의 의사코드는 아래와 같다.
```
1. 배열의 길이가 n 인 배열에서 최대값을 찾는다.  
2. 배열의 마지막 위치에 있는 값과 최대값의 위치를 바꾼다.    
3. 배열의 길이가 n - 1 이라고 가정하여 위 가정을 반복한다.  
```

- 버블정렬의 의사코드는 아래와 같다.
```
1. 첫 번째와 두 번째 원소를 비교하여 첫 번째 원소가 크면 위치를 변경한다.  
2. 두 번째와 세 번째 원소를 비교하여 두 번째 원소가 크면 위치를 변경한다.  
...
위 과정을 거치면 제일 마지막에 최대값이 위치하게 된다.  
위 과정을 배열의 길이가 n 일 때 했다고 가정하면 이후 배열의 길이가 n - 1 이라 가정하여 위 가정을 반복한다.
```

- 삽입정렬의 의사코드는 아래와 같다.
```
첫 번째 원소는 무조건 정렬되어 있다.
두 번째 원소를 비교하여 정렬한다.
세 번째 원소와 위 두 개 값이 정렬된 배열을 비교하여 정렬한다.
네 번째 원소와 위 세 개 값이 정렬된 배열을 비교하여 정렬한다.
...
위 과정을 반복한다.
```

- 병합정렬의 의사코드는 아래와 같다.
```
배열을 위치를 기준으로 반으로 나눈다.
왼쪽 배열을 병합정렬을 사용하여 정렬한다.
오른쪽 배열을 병합정렬을 사용하여 정렬한다.
왼쪽 배열과 오른쪽 배열을 삽입 정렬을 응용하여 정렬한다.
```

- 퀵정렬의 의사코드는 아래와 같다.
```
1. 배열에 있는 임의의 값을 기준으로 왼쪽에 위치한 원소는 기준값보다 작도록,  
오른쪽에 위치한 값은 기준값보다 크도록 불완전하게 정렬한다.
2. 왼쪽 배열을 1. 의 과정을 반복하여 완벽한 정렬을 만든다.  
3. 오른쪽 배열을 1. 의 과정을 반복하여 완벽한 정렬을 만든다.
```

- 힙정렬의 의사코드는 아래와 같다.
```
1. 배열의 원소를 차례대로 힙에 삽입한다.  
2. 힙에서 차례대로 원소를 빼내어 배열에 채운다.  
(힙은 특별한 트리 중 하나로 루트 노드에 High Priority 를 갖는 원소가 위치한다.)
```

- 결정트리를 활용하면 두 원소 간의 비교가 필요한 정렬은 최소 O(n*log n) 의 시간복잡도가 필요함을 증명할 수 있다.  

- 기수정렬의 의사코드는 아래와 같다.  
```
1. 각 원소의 길이가 같고 그 가능성이 제한된 배열이 존재할 때 (ex. 네자리 수만으로 배열이 구성되어 있을 때)
2. 가장 적은 영향을 미치는 원소 내 위치를 기준으로 bucket 를 만들어 정렬한다. (ex. 1의 자리수로 배열한다.)
3. 차례대로 큰 영향을 미치는 원소 내 위치를 기준으로 bucket 을 만들어 정렬을 수행한다.
```

- 계수정렬의 의사코드는 아래와 같다.
```
1. 각 원소의 존재 가능한 값이 제한되어 있을 때  
2. counter 를 만들어서 배열을 순회하여 원소의 개수를 구한다.  
3. counter 에서 차례대로 빼냄으로써 정렬을 수행한다.
```

- 위 두 정렬은 원소의 형태에 제한을 함으로써 O(n) 의 성능을 낼 수 있는 특수한 정렬 중 하나이다.  

---

### 4. 선택 알고리즘

- k 번 째로 작은 원소를 탐색하기 위해 퀵 정렬을 응용하여 임의의 기준값을 바탕으로 배열의 원소를 줄여가면서 탐색할 수 있다.  
- 최악의 경우에 O(n^2) 이 소요되나 평균적으로 O(n) 이 소요된다.  
- linear select 를 사용하면 최악의 경우에도 선형시간이 보장되지만 오버헤드가 클 수 있다.  
- linear select 가 선형시간이 보장되는 이유는 M 을 기준으로  
왼쪽 배열과 오른쪽 배열의 비율이 차이가 나봤자 최대 1:3 이라는 것이 보장되기 때문이다.
```
Linear Select
1. 원소의 총 수가 5개 이하이면 원하는 원소를 찾고 알고리즘을 끝낸다.  
2. 배열을 배열의 길이가 5개로 이루어진 sub 배열들로 나누어 각 배열의 중앙값을 구한다.  
3. 중앙값들의 중앙값을 Linear Select 를 호출하여 구하고 이를 M 이라고 한다.
4. M 을 기준으로 퀵정렬과 유사하게 배열을 분할하고, 적합합 그룹을 기준으로 Linear Select 를 호출한다.
```
