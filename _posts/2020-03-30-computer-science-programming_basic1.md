---
layout: post
topic: computer-science
title: 프로그래밍 기초1
---

프로그래밍에 대한 기초, 더 정확히는 동작 원리에 대해 알고 싶어 책을 한 권 읽었다.  
"뇌를 자극하는 프로그래밍 원리(CPU부터 OS까지)" 라는 절판된 책인데 유명해서 그런지 중고가가 꽤 나갔다.  
아무튼 약 한 달에 걸쳐 이 책을 보았고, 알지 못하던 내용이라 재미있게 읽었다.  

정리하는 겸 하여 이 포스팅에 읽은 내용을 정리하고자 한다.  
글은 목차 별로 나뉘어 작성될 것이다.  


## CPU와 친해지기  

#### 1장) 0과 1의 세상
    - 컴퓨터의 역사 및 2진수와 관련된 인트로 챕터. 설명 패스

#### 2장) 논리회로
    - 게이트란 특정 연산을 하는 단위를 뜻한다.
    - 기본 게이트로 NOT, AND, OR 게이트가 있다. (+XOR)
    - Boole 대수라는 개념이 있는데 집합의 연산과 유사하다.
    - ALU(Arithemetic Logic Unit) 는 가장 기초적인 모듈이다.
    - + 등의 연산에서 올림값은 __캐리(carry)__라고 표현한다.
    - 카르노 맵이라는 방법으로 Boole 대수의 연산을 간단화 할 수 있지만 카르노 맵 역시 변수가 많아지면 복잡해져서 실제 사용은 어렵다.
    - MUX(Multiplexer) 는 N 개의 신호가 들어왔을 때 M 개의 신호를 출력하는 모듈을 뜻한다. 이를 MUX NxM 으로 표현한다. 보통 M=1이고, [log2(N)] bit의 선택 신호가 필요하다.

#### 3장) 조합 및 순차 논리회로
    - 조합 논리회로는 특점 시점의 출력이 특점 시점의 입력에 의해 결정되는 논리회로를 뜻한다.
    - 순차 논리회로는 특점 시점의 입력과 상태값을 함께 고려하여 출력이 결정되는 논리회로를 뜻한다.
    - 플립플롭이란 AND, OR 등의 게이트를 이용해서 상태를 저장할 수 있는 메모리이다.
    - 플립플롭의 종류로 RS 플립플롭, D 플립플롭, T 플립플롭, JK 플립플롭 등이 있다. 자세한 내용은 위키 등을 참고할 것.
    
#### 4장) 컴퓨터의 두뇌 - CPU  
    - CPU 는 회로의 동작을 결정짓는 컨트롤 입력이 따로 존재하는 범용 논리회로이다.
    - 32 Bit Adder 의 구현에 대한 자세한 정보는 위키 등을 참고할 것.
    - 리플 캐리와 캐리 룩 어헤드에 대한 내용 역시 위키 등을 참고할 것.
    - 2의 보수는 두 수의 합의 자릿수가 모두 1인 방법론이다. 뺄셈 시 캐리를 고려해야 하며 중복 문제(0000, 1111)이 있다.
    - 1의 보수는 두 수의 합의 자릿수가 모두 0인 방법론이다. 뺄셈 시 캐리 고려할 필요 없이 반전 후 최하위 캐리를 1로 설정하면 된다. 중복 문제 없다.
    - 인스트럭션를 1:1 로 대응하여 만든 언어가 어셈블리어이다.
    - C에서 컴파일 할 때에 어셈블리어를 거쳐 인스트럭션을 만든다.
    
#### 5장) CPU의 필수 도구 - 레지스터와 클럭
    - 레지스터란 CPU가 연산하면서 필요한 정보를 임시로 저장하는 일종의 메모리이다.
    - 클럭이란 CPU의 타이머로 매 클럭이 체크될 때마다 레지스터의 값이 변경된다.

#### 6장) CPU의 언어 - 인스트럭션
    - 프로그램 저장방식 컴퓨터란 여러 개의 인스트럭션을 미리 작서하여 메모리에 위치시키고, CPU가 인스트럭션을 읽어와서(FETCH) 실행하는 개념을 뜻한다.
    - Operand(연산자)를 상수값으로 결정하여 인스트럭션에 기록하는 방식을 I-타입 인스트럭션이라고 한다.
    - 반면 레지스터를 지정하는 방식을 R-타입 인스트럭션이라고 한다.
    - CISC란 모든 인스트럭션이 한 주기(1CPI)에 수행되도록 인스트럭션을 설계하지 않고, 각 인스트럭션마다 다른 CPI를 갖고 있도록 인스트럭션 셋을 구성하는 것이다.
    - CISC는 인스트럭션 종류가 많고 길이가 제각각이어서 하드웨어적 설계가 복잡해질 수 밖에 없다.
    - RISC란 모든 인스트럭션이 일정한 형태 및 사이즈를 갖도록 인스트럭션 셋을 구성하는 것이다. 인스트럭션 종류가 적으며, 많은 범용 레지스터를 필요롤 한다.
    - RISC 사용 시 파이프라이닝을 통하여 높은 성능을 얻을 수 있다.
    - 보다 자세한 CISC, RISC 에 대한 자료는 위키 등을 참고할 것.

#### 7장) 실전 인스트럭션 셋 - MIPS
    - MIPS 란 RISC 방식 인스트럭션 셋의 일종이다.
    - PC(Program Counter) 레지스터란 메모리 상의 현재 수행해야 하는 인스트럭션 주소를 가리키는 레지스터를 뜻한다.
    - MIPS는 32개의 레지스터를 갖고, 레지스터 주소를 가리키기 위해 2^5(32) Bit 가 필요하다.
    - 레지스터 간의 연산을 R-타입 인스트럭션이라 한다. ADD, SUB 등이 해당한다.
    - MIPS R-타입 인스트럭션은 |OP|rs|rt|rd|shamt|funct (OP: 연산자파트1, rs: 피연산자1, rt: 피연산자2, rd: 결과저장레지스터, shamt: shift 양, funct: 연산자파트2)
    - MIPS I-타입 인스트럭션은 |OP|rs|rt|Constant| (OP: 연산자파트, rs: 피연산자, rt: 결과저장레지스터, Constant: 상수값), Constatnt 는 offset으로 활용되어 rs + Constant 에 해당하는 메모리 주소에 access한다.
    - MIPS J-타입 인스트럭션은 |OP|Address| 로 이루어져 있으며 분기문(if) 등에 활용된다.

#### 8장) 실전 CPU 설계 - MIPS의 데이터 경로
    - CPU가 인스트럭션을 수행하는 과정은 Fetch, 디코딩, 실행, Write Back(결과값 저장) 으로 나뉜다.
    - 인스트럭션 패치와 메모리에서 데이터를 읽어오는 것의 가장 큰 차이점은 메모리를 읽는 것은 개발자의 의도대로 되지만 인스트력션 패치에서의 메모리 어드레스는 하드웨어 설계자에 의해 결정된다는 것이다.
    - CPU는 전원이 켜지면 자동으로 미리 정해진 메모리 어드레스 값을 읽어와 이를 인스트럭션으로 이해한다.
    - 디코딩이란 패치 후 인스트럭션을 필드별로 분해하여 적절한 모듈에 그 값을 인가하는 과정이다.
    - 각 인스터럭션 타입 별 구조를 알기 위해서는 위키 등을 참고할 것.

#### 9장) 쉼 없이 일하라 - 파이프라이닝
    - 실행단계는 크게 Fetch, Decoding, Execution, Memeory Access, Write-Back 의 5단계로 나뉘고, 각 단계를 일부 중첩하여 CPU의 모든 부분이 동시에 일할 수 있도록 하는 것을 파이프라이닝이라고 한다.
    - CPU 구조 상의 한계, 이전 단계의 데이터 참조, 분기문의 결정 소요 단계 등이 파이프라이닝을 가로막는 대표적인 요소이다.
    - CPU 구조 상의 한계의 예시 중 하나로 Fetch 와 Memory Access 는 둘 다 메모리에 접근하기 때문에 동시에 수행될 수 없는 상황이 있다.
    - 데이터 포워딩이란 각 단계의 출력값을 다른 단계의 입력값으로 바로 연결해주는 경로를 만드는 것이다. 100%의 방법은 아니나 성능 개선을 꽤할 수 있다.

## 인간의 말을 배운 컴퓨터

#### 10장) 컴파일러의 등장
    - 어셈블리어는 인스트럭션과 1:1 매칭되므로 CPU 종속적일 수 밖에 없어서 생산성이 떨어졌다.
    - 이를 해결하기 위해 고급언어가 등장하였고, 대표적인 언어가 C 이다.

#### 11장) 변수의 정체
    - C 에서 값 할당 없이 선언된 변수는 아무런 인스트럭션을 생성하지 않는다.
    - 변수 범위를 넘어서는 값은 상단 부분이 truncate 되어 저장된다.
    - 값 비교를 위해서는 상수이든 변수이든 두 값 모두 레지스터에 올라와 있어야 한다.
    - 포인터 변수 역시 특정한 값을 저장하는 평범한 변수에 지나지 않는다. (예: int * a = 10; int * b = 20; => (int) a + (int) b == 30 이 성립)
    - 포인터 변수의 크기는 컴퓨터 비트(32비트, 64비트)로 일정하다.
    - 포인터 변수의 형이 바뀌는 것은 포인터 변수의 크기가 아니라 해당 포인터 변수로 메모리에 접근할 때 읽는 메모리 크기가 변하는 것이다.
    - void * FuncAddr (); FuncAddr = Func; FuncAddr(); 과 같은 형식으로 함수 포인터 변수를 생성하여 실행할 수 있다. 함수포인터 변수는 해당 함수의 주소를 기억하여 실행하는 것으로, 인스트럭션에서 직접수행과는 차이가 존재한다.
    - 링크란 외부 소스로부터의 코드가 합쳐지는 과정을 뜻한다. 실제 우리가 컴파일하는 것은 링크까지 포함된 것이다.
    - DLL 을 사용할 경우 동적으로 함수를 찾아서 사용하는데 이 때에 함수 포인터가 활용된다. 또한 콜백에서도 활용된다. 대표적인 콜백 예시록 퀵소트가 있다.
    - 댕를링 포인터랑 유효하지 않은 주소를 갖고 있는 포인터를 뜻한다. 이런 문제를 해결하기 위해 선언 및 해제 할 때에 NULL 로 선언하고, 사용 시에는 NULL 여부를 체크하는 습관이 요구된다.
    - 일반 포인터는 void * ptr; (void *) ptr 등의 형태로 선언되고, 메모리 자체의 값 복사 등을 할 때에 활용된다.
    - 배열은 포인터와 유사하지만, 포인터는 특정 메모리 크기를 확보할 수 없는 반면 배열은 특정 메모리 크기를 확보한다.
    - C에서는 1차원 배열만 존재한다. 예를 들어 int arr[3][5]; 배열은 사실 int[5] 의 1차원 배열이 3개 있는 배열이다.

#### 12장) 메모리 나누기 - 코드, 데이터, 스택, 힙
    - 메모리는 인스트럭션이 위치하는 코드 세그먼트, 전역 변수가 위치하는 데이터 세그먼트, 지역 변수가 위치하는 스택 세그먼트, 동적 메모리 할당을 위한 힙 세그먼트로 나뉜다.
    - global 변수의 초기값 할당은 브레이크 등을 걸어 확인해도 확인할 수 없다. 그 이유는 global 변수 데이터 세그먼트에 저장되어 코드 세그먼트와 함께 exe 를 실행할 때에 메모리에 로드되기 때문이다.
    - 스택 구조를 사용함으로써 재귀호출을 사용할 수 있다. 재귀호출할 때에 너무 많은 스택이 쌓어 스택 세그먼트를 벗어날 때에 Stack Overflow 가 발생한다.
    - 보통 스택 세그먼트의 크기는 어느 정도 경험적이고 막연한 값으로 결정되는데, 컴파일 할 때에 옵션을 줄 수 있다.
    - 힙공간에 100 바이트를 할당하기 위해 malloc(100); 을 한다면 실제로는 Header + 할당을 위해 a + 100 의 공간을 차지한다.
    - 힙 할당 시 연속된 여유 메모리 공간에 대한 정보가 필요하므로 이전 주소 및 다음 주소 등에 대한 정보를 담는데, 이를 위해 Double Linked List 의 형태가 많이 사용된다.

#### 13장) 함수가 호출되기까지

## 프로그램의 정부 - 운영체제(OS)

#### 14장) OS의 정체

#### 15장) OS랑 친해지기 - 핵심 OS 요소

#### 16장) OS 속 들여다보기