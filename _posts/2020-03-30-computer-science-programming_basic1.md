---
layout: post
topic: computer-science
title: 프로그래밍 기초1
---

프로그래밍에 대한 기초, 더 정확히는 동작 원리에 대해 알고 싶어 책을 한 권 읽었다.  
"뇌를 자극하는 프로그래밍 원리(CPU부터 OS까지)" 라는 절판된 책인데 유명해서 그런지 중고가가 꽤 나갔다.  
아무튼 약 한 달에 걸쳐 이 책을 보았고, 알지 못하던 내용이라 재미있게 읽었다.  

정리하는 겸 하여 이 포스팅에 읽은 내용을 정리하고자 한다.  
글은 목차 별로 나뉘어 작성될 것이다.  


## CPU와 친해지기  

#### 1장) 0과 1의 세상
    - 컴퓨터의 역사 및 2진수와 관련된 인트로 챕터. 설명 패스

#### 2장) 논리회로
    - 게이트란 특정 연산을 하는 단위를 뜻한다.
    - 기본 게이트로 NOT, AND, OR 게이트가 있다. (+XOR)
    - Boole 대수라는 개념이 있는데 집합의 연산과 유사하다.
    - ALU(Arithemetic Logic Unit) 는 가장 기초적인 모듈이다.
    - + 등의 연산에서 올림값은 __캐리(carry)__라고 표현한다.
    - 카르노 맵이라는 방법으로 Boole 대수의 연산을 간단화 할 수 있지만 카르노 맵 역시 변수가 많아지면 복잡해져서 실제 사용은 어렵다.
    - MUX(Multiplexer) 는 N 개의 신호가 들어왔을 때 M 개의 신호를 출력하는 모듈을 뜻한다. 이를 MUX NxM 으로 표현한다. 보통 M=1이고, [log2(N)] bit의 선택 신호가 필요하다.

#### 3장) 조합 및 순차 논리회로
    - 조합 논리회로는 특점 시점의 출력이 특점 시점의 입력에 의해 결정되는 논리회로를 뜻한다.
    - 순차 논리회로는 특점 시점의 입력과 상태값을 함께 고려하여 출력이 결정되는 논리회로를 뜻한다.
    - 플립플롭이란 AND, OR 등의 게이트를 이용해서 상태를 저장할 수 있는 메모리이다.
    - 플립플롭의 종류로 RS 플립플롭, D 플립플롭, T 플립플롭, JK 플립플롭 등이 있다. 자세한 내용은 위키 등을 참고할 것.
    
#### 4장) 컴퓨터의 두뇌 - CPU  
    - CPU 는 회로의 동작을 결정짓는 컨트롤 입력이 따로 존재하는 범용 논리회로이다.
    - 32 Bit Adder 의 구현에 대한 자세한 정보는 위키 등을 참고할 것.
    - 리플 캐리와 캐리 룩 어헤드에 대한 내용 역시 위키 등을 참고할 것.
    - 2의 보수는 두 수의 합의 자릿수가 모두 1인 방법론이다. 뺄셈 시 캐리를 고려해야 하며 중복 문제(0000, 1111)이 있다.
    - 1의 보수는 두 수의 합의 자릿수가 모두 0인 방법론이다. 뺄셈 시 캐리 고려할 필요 없이 반전 후 최하위 캐리를 1로 설정하면 된다. 중복 문제 없다.
    - 인스트럭션를 1:1 로 대응하여 만든 언어가 어셈블리어이다.
    - C에서 컴파일 할 때에 어셈블리어를 거쳐 인스트럭션을 만든다.
    
#### 5장) CPU의 필수 도구 - 레지스터와 클럭
    - 레지스터란 CPU가 연산하면서 필요한 정보를 임시로 저장하는 일종의 메모리이다.
    - 클럭이란 CPU의 타이머로 매 클럭이 체크될 때마다 레지스터의 값이 변경된다.

#### 6장) CPU의 언어 - 인스트럭션
    - 프로그램 저장방식 컴퓨터란 여러 개의 인스트럭션을 미리 작서하여 메모리에 위치시키고, CPU가 인스트럭션을 읽어와서(FETCH) 실행하는 개념을 뜻한다.
    - Operand(연산자)를 상수값으로 결정하여 인스트럭션에 기록하는 방식을 I-타입 인스트럭션이라고 한다.
    - 반면 레지스터를 지정하는 방식을 R-타입 인스트럭션이라고 한다.
    - CISC란 모든 인스트럭션이 한 주기(1CPI)에 수행되도록 인스트럭션을 설계하지 않고, 각 인스트럭션마다 다른 CPI를 갖고 있도록 인스트럭션 셋을 구성하는 것이다.
    - CISC는 인스트럭션 종류가 많고 길이가 제각각이어서 하드웨어적 설계가 복잡해질 수 밖에 없다.
    - RISC란 모든 인스트럭션이 일정한 형태 및 사이즈를 갖도록 인스트럭션 셋을 구성하는 것이다. 인스트럭션 종류가 적으며, 많은 범용 레지스터를 필요롤 한다.
    - RISC 사용 시 파이프라이닝을 통하여 높은 성능을 얻을 수 있다.
    - 보다 자세한 CISC, RISC 에 대한 자료는 위키 등을 참고할 것.

#### 7장) 실전 인스트럭션 셋 - MIPS
    - MIPS 란 RISC 방식 인스트럭션 셋의 일종이다.
    - PC(Program Counter) 레지스터란 메모리 상의 현재 수행해야 하는 인스트럭션 주소를 가리키는 레지스터를 뜻한다.
    - MIPS는 32개의 레지스터를 갖고, 레지스터 주소를 가리키기 위해 2^5(32) Bit 가 필요하다.
    - 레지스터 간의 연산을 R-타입 인스트럭션이라 한다. ADD, SUB 등이 해당한다.
    - MIPS R-타입 인스트럭션은 |OP|rs|rt|rd|shamt|funct (OP: 연산자파트1, rs: 피연산자1, rt: 피연산자2, rd: 결과저장레지스터, shamt: shift 양, funct: 연산자파트2)
    - MIPS I-타입 인스트럭션은 |OP|rs|rt|Constant| (OP: 연산자파트, rs: 피연산자, rt: 결과저장레지스터, Constant: 상수값), Constatnt 는 offset으로 활용되어 rs + Constant 에 해당하는 메모리 주소에 access한다.
    - MIPS J-타입 인스트럭션은 |OP|Address| 로 이루어져 있으며 분기문(if) 등에 활용된다.

#### 8장) 실전 CPU 설계 - MIPS의 데이터 경로
    - CPU가 인스트럭션을 수행하는 과정은 Fetch, 디코딩, 실행, Write Back(결과값 저장) 으로 나뉜다.
    - 인스트럭션 패치와 메모리에서 데이터를 읽어오는 것의 가장 큰 차이점은 메모리를 읽는 것은 개발자의 의도대로 되지만 인스트력션 패치에서의 메모리 어드레스는 하드웨어 설계자에 의해 결정된다는 것이다.
    - CPU는 전원이 켜지면 자동으로 미리 정해진 메모리 어드레스 값을 읽어와 이를 인스트럭션으로 이해한다.
    - 디코딩이란 패치 후 인스트럭션을 필드별로 분해하여 적절한 모듈에 그 값을 인가하는 과정이다.
    - 각 인스터럭션 타입 별 구조를 알기 위해서는 위키 등을 참고할 것.

#### 9장) 쉼 없이 일하라 - 파이프라이닝
    - 실행단계는 크게 Fetch, Decoding, Execution, Memeory Access, Write-Back 의 5단계로 나뉘고, 각 단계를 일부 중첩하여 CPU의 모든 부분이 동시에 일할 수 있도록 하는 것을 파이프라이닝이라고 한다.
    - CPU 구조 상의 한계, 이전 단계의 데이터 참조, 분기문의 결정 소요 단계 등이 파이프라이닝을 가로막는 대표적인 요소이다.
    - CPU 구조 상의 한계의 예시 중 하나로 Fetch 와 Memory Access 는 둘 다 메모리에 접근하기 때문에 동시에 수행될 수 없는 상황이 있다.
    - 데이터 포워딩이란 각 단계의 출력값을 다른 단계의 입력값으로 바로 연결해주는 경로를 만드는 것이다. 100%의 방법은 아니나 성능 개선을 꽤할 수 있다.

## 인간의 말을 배운 컴퓨터

#### 10장) 컴파일러의 등장
    - 어셈블리어는 인스트럭션과 1:1 매칭되므로 CPU 종속적일 수 밖에 없어서 생산성이 떨어졌다.
    - 이를 해결하기 위해 고급언어가 등장하였고, 대표적인 언어가 C 이다.

#### 11장) 변수의 정체
    - C 에서 값 할당 없이 선언된 변수는 아무런 인스트럭션을 생성하지 않는다.
    - 변수 범위를 넘어서는 값은 상단 부분이 truncate 되어 저장된다.
    - 값 비교를 위해서는 상수이든 변수이든 두 값 모두 레지스터에 올라와 있어야 한다.
    - 포인터 변수 역시 특정한 값을 저장하는 평범한 변수에 지나지 않는다. (예: int * a = 10; int * b = 20; => (int) a + (int) b == 30 이 성립)
    - 포인터 변수의 크기는 컴퓨터 비트(32비트, 64비트)로 일정하다.
    - 포인터 변수의 형이 바뀌는 것은 포인터 변수의 크기가 아니라 해당 포인터 변수로 메모리에 접근할 때 읽는 메모리 크기가 변하는 것이다.
    - void * FuncAddr (); FuncAddr = Func; FuncAddr(); 과 같은 형식으로 함수 포인터 변수를 생성하여 실행할 수 있다. 함수포인터 변수는 해당 함수의 주소를 기억하여 실행하는 것으로, 인스트럭션에서 직접수행과는 차이가 존재한다.
    - 링크란 외부 소스로부터의 코드가 합쳐지는 과정을 뜻한다. 실제 우리가 컴파일하는 것은 링크까지 포함된 것이다.
    - DLL 을 사용할 경우 동적으로 함수를 찾아서 사용하는데 이 때에 함수 포인터가 활용된다. 또한 콜백에서도 활용된다. 대표적인 콜백 예시록 퀵소트가 있다.
    - 댕를링 포인터랑 유효하지 않은 주소를 갖고 있는 포인터를 뜻한다. 이런 문제를 해결하기 위해 선언 및 해제 할 때에 NULL 로 선언하고, 사용 시에는 NULL 여부를 체크하는 습관이 요구된다.
    - 일반 포인터는 void * ptr; (void *) ptr 등의 형태로 선언되고, 메모리 자체의 값 복사 등을 할 때에 활용된다.
    - 배열은 포인터와 유사하지만, 포인터는 특정 메모리 크기를 확보할 수 없는 반면 배열은 특정 메모리 크기를 확보한다.
    - C에서는 1차원 배열만 존재한다. 예를 들어 int arr[3][5]; 배열은 사실 int[5] 의 1차원 배열이 3개 있는 배열이다.

#### 12장) 메모리 나누기 - 코드, 데이터, 스택, 힙
    - 메모리는 인스트럭션이 위치하는 코드 세그먼트, 전역 변수가 위치하는 데이터 세그먼트, 지역 변수가 위치하는 스택 세그먼트, 동적 메모리 할당을 위한 힙 세그먼트로 나뉜다.
    - global 변수의 초기값 할당은 브레이크 등을 걸어 확인해도 확인할 수 없다. 그 이유는 global 변수 데이터 세그먼트에 저장되어 코드 세그먼트와 함께 exe 를 실행할 때에 메모리에 로드되기 때문이다.
    - 스택 구조를 사용함으로써 재귀호출을 사용할 수 있다. 재귀호출할 때에 너무 많은 스택이 쌓어 스택 세그먼트를 벗어날 때에 Stack Overflow 가 발생한다.
    - 보통 스택 세그먼트의 크기는 어느 정도 경험적이고 막연한 값으로 결정되는데, 컴파일 할 때에 옵션을 줄 수 있다.
    - 힙공간에 100 바이트를 할당하기 위해 malloc(100); 을 한다면 실제로는 Header + 할당을 위해 a + 100 의 공간을 차지한다.
    - 힙 할당 시 연속된 여유 메모리 공간에 대한 정보가 필요하므로 이전 주소 및 다음 주소 등에 대한 정보를 담는데, 이를 위해 Double Linked List 의 형태가 많이 사용된다.

#### 13장) 함수가 호출되기까지
    - 파스칼 같은 언어의 경우 프로시져(리턴이 없는 특정 기능)과 함수를 구분하지만 C에서는 void 형 함수로 대체하고 있다.
    - 함수는 1) 종료 후 호출 지점으로 복귀 2) Caller-Callee 간의 데이터 전달 3) 호출 중첩이 가능해야 한다.
    - 함수가 호출될 때마다 스텍 세그먼트 영역 안에 스택 프레임이 생성된다.
    - Caller 는 Callee 가 종료되기 전에 먼저 종료되지 않는다.
    - 스택 포인터(SP)는 현재 스택프레임의 위치를 나타낸다.
    - 복귀 주소는 4바이트이고 스택 프레임의 제일 위에 위치한다.
    - 보통 Callee 는 eax 레지스터에 결과값을 저장하고, Caller는 eax 레지스터에 있는 값을 리턴 값으로 간주한다.
    - 함수 호출 규약으로는 __cdecl 과 __stdcall 이 있다. __cdecl 호출에서는 Callee 의 스택을 해지하는 책임이 Caller 에 있다. __stdcall 에서는 Callee 에 해지 책임이 있다.
    - C 에서의 기본 호출 규약은 __cdecl 이다. 
    - printf 같은 가변인자 함수의 경우 __cdecl 규약은 가능하나 __stdcall 규약은 불가능하다.
    - __fastcall 은 최대 두 개 까지의 인자를 메모리 엑세스하지 않고 바로 레지스터로 전달해 속도를 높이는 규약이다. 컴파일러에 따라 구현 불가능할 수도 있다.

## 프로그램의 정부 - 운영체제(OS)

#### 14장) OS의 정체
    - Shell 등도 OS 위에서 실행되는 하나의 프로그램이며, OS는 이러한 프로그램이 실행될 수 있도록 하는 기능의 집합으로 이해할 수 있다.
    - 활용도를 높이기 위해 한 프로그램에서의 I/O 작업이 끝날 때까지 다른 프로그램을 수행하는 것은 다중 프로그래밍 또는 멀티태스킹이라고 한다.
    - 도스는 일괄처리 시스템의 일종으로, 프로그램이 수행되다가 I/O 작업 등으로 제어권이 넘어가면 다른 프로그램을 수행하는 식이다.
    - 반면 윈도우즈 프로그램은 이벤트 드리븐 방식으로, 특정 이벤트가 발생하면 해당 이벤트만 처리하고 유휴 상태로 프로그램을 돌려놓는 방식이다.
    - 비선점형 멀티태스킹은 한 프로그램이 제어권을 양보하지 않으면 다른 프로그램이 이를 가져올 방법이 없는 멀티태스킹 방법이다.
    - 선점형 멀티태스킹은 프로그램 하나가 CPU를 독점할 수 없는 방식의 멀티태스킹 방법을 뜻한다.

#### 15장) OS랑 친해지기 - 핵심 OS 요소
    - 프로세스란 프로그램이 실행되기 위해 필요한 자원 소유의 단위를 뜻한다.
    - 스레드란 프로세스의 코드를 수행하는 단위를 뜻한다.
    - 기본적으로 하나의 프로세스에 최소 한 개의 스레드가 존재한다.
    - 한 스레드의 일부 코드를 수행하고 다른 스레드의 코드를 수행하려고 할 때마다 문맥 전환(Context Switching)이 발생하는데, 해당 인스트럭션에 필요한 레지스터 정보를 메모리에 저장하고 불러와야 하므로 잦은 문맥전환은 속도 저하의 원인이 된다.
    - 멀티스레딩에 있어 동기화가 중요한 이슈인데, 크리티컬 섹션(Critical Section) 이나 뮤텍스(Mutex) 등의 객체가 동기화를 수행할 수 있다.
    - Lock-Unlock 이 크리티컬 섹션에서 쓰인다.
    - 데드락은 두 스레드가 각각 서로 다른 자원을 하나씩 소유한 채 상대방의 자원을 요청하는 경우에 발생한다. 이 경우 평행(정지) 상태를 유지한다.
    - 프로세스 간에도 I/O 장치 등을 놓고 경쟁을 펼쳐 데드락이 발생할 수 있다.
    - 일반적으로 하드디스크 등의 장치를 읽는 것은 느리므로 CPU가 직접하지 않고 컨트롤러에 해당 명령(Read/Write) 을 전달하면 컨트롤러가 해당 명령을 수행한다. 컨트롤러가 해당 명령을 수행하면 CPU에 인터럽트를 전달한다. 그러면 CPU는 현재 수행 죽인 인스트럭션을 임시 저장하고 지정된 주소로 점프하여 인스트럭션을 수행한 후 다시 되돌아와서 진행 중이던 작업을 다시 수행한다.
    - Blocked I/O 는 해당 명령을 컨트롤러에 전달하고 바로 다음 인스트럭션을 수행하는 것이고, Non-Blocked I/O 는 인터럽트가 발생한 후에야 다음 인스트럭션을 수행하는 것이다.
    - 일반적으로 단일스레드 프로그램의 경우 데이터가 사용되는 경우가 많으므로 Non-Blocked I/O 가 의미가 없는 경우가 많으나 멀티스레드 프로그램의 경우 성능 향상을 꾀할 수 있다.
    - 서버 프로그램에서 멀티스레딩이 자주 활용되는데, 클라이언트 수가 많아지면 문맥전환에 비용이 많이 들어 성능이 향상되지 않는다.
    - Overlapped I/O 는 윈도우즈NT에서 처음 도입된 방식으로, 통신 장치 등에서의 Read/Write 를 Non-Blocked I/O로 동작하는 것을 말한다.
    - IOCP(I/O Completion Port) 의 핵심은 문맥 전환을 없애는 것으로 1) CPU 개수만큼의 스레드를 미리 생성해둔 후(스레드풀(Thread Pool) 이라고 하고 각각의 스레드를 워커스레드(Worker Thread) 라고 함) 2)IOCP 객체가 존재하여 I/O 작업 완료 시 IOCP 객체에 작업 완료 통지가 발생하고 3) IOCP 객체는 스레드 풀에 있는 워커 스레드 중 현재 대기 상태에 있는 스레드에 작업 완료 통지를 전달해 이후 작업을 수행한다.
    - IOCP는 스레드풀을 유지하여 쓸데 없는 문맥전환이 발생하지 않고, 스레드 생성에 대한 비용도 감소시켰다.

#### 16장) OS 속 들여다보기
    - 각 프로세스마다 받아서 사용하는 고유 메모리를 가상 메모리(Virtual Memory)라고 한다.
    - 컴파일러에 의해 생성된 파일이 목적파일이라 불리는 .obj 파일이고, printf 등 외부 함수에 대한 구현에 대한 정보 없이 선언에 대한 정보만 존재한다. 이러한 obj 파일과 외부 라이브러리 파일들을 검사하여 합침으로써 외부 함수를 사용할 수 있게 하는 exe 파일을 만드는 과정을 링킹이라고 한다.
    - 컴파일 시간 주소 바인딩이란 컴파일 할 때에 call 하는 주소가 절대적으로 결정되는 방법론이다.
    - 적재 시간 주소 바인딩이란 메모리에 해당 프로그램이 올라갈 때에 call 주소가 결졍되는 방법론이다.
    - 실행 시간 주소 바인딩이란 실행을 위해 CPU가 해당 인스트럭션을 수행할 때에 주소가 결정되는 방법론이다.
    - 스와핑이란 메모리가 두 프로세스 중 하나의 정보만 수용할 수 있을 정도로 작을 경우에 해당 정보를 HDD 등에 기록해두는 것을 말한다. 이 때 해당 문맥 정보를 HDD에 옮기는 것을 롤아웃(Roll Out), 다시 불러 읽는 것을 롤인(Roll In) 이라고 한다.
    - 외부 단편화란 메모리의 빈 공간이 작게 쪼개지는 현상을 말한다. 프로세스 적재 및 제거의 과정에서 발생한다.
    - 공간구역성(Spatial Locality) 와 시간구역성(Temporal Locality) 란 비슷한 주소에 위치할 수록, 최근에 사용되었을 수록 다음에 사용될 가능성이 높다는 프로그램의 특성을 가리킨다.
    - 페이징은 공간구역성과 시간구역성이라는 프로그램의 특징에 기반하여 프로세스를 수행할 때 특정한 사이즈로 나눠 해당 부분만 읽어와서 수행하는 것을 뜻한다.
    - 이 때 CPU는 프로세스의 수행하려는 코드 및 데이터가 올라와있는지 체크하고, 올라와 있다면 수행하고 올라와 있지 않다면 페이지 폴트(Page Fault)를 발생시킨다. 페이지 폴트가 발생하면 마찬가지로 해당 부분이 포함되는 페이지 정보를 읽어온다. 이러한 방법을 요구 페이징(Demand Paging)이라 하고, 단순히 프로세스를 올리는 것보다 훨씬 많은 프로세스를 동시에 수행할 수 있다는 장점이 있다.
    - 내부 단편화란 이렇게 페이징 방법을 쓸 때 실행파일의 맨 마지막 부분 등에서 일부 정보가 비어있을 수 있는데, 이렇게 비어있는 낭비 공간을 뜻한다.
    - 페이징 방법을 사욜할 때 메모리에 올라와 있는 프레임의 순서는 뒤섞여 있으므로 페이지 번호와 프레임 번호를 맵핑하는 테이블이 필요하다. 이를 페이징 테이블이라고 하고, 각 프로세스마다 페이징 테이블이 필요하다.
    - 이중 페이징 테이블을 생성하여 효율성을 높일 수 있다. 더 자세한 정보는 위키 등을 참고할 것.
    - TLBs(Transition Look-aside Buffers) 라는 캐시 메모리가 CPU에 탑재되어 페이징 테이블을 전담한다. 보다 자세한 정보는 위키 등을 참고할 것.
    - 페이징을 활용해서 여러 프로세스에서 공용으로 사용되는 코드를 한 번만 로드할 수 있다.
    - 실시간 운영체제 RTOS(Real TIme Operating System) 이란 1) 프로세스가 수행하는 결과 뿐 아니라 도출 시점이 중요한 목표가 되는 시스템 2) 항상 예측 가능한 시간 안에 처리할 수 있는 시스템 3) 시간적 제약이 있는 작업을 다루는 시스템 이다.
    - 미사일 컨트롤 장치와 같이 실시간 처리가 실패했을 경우 그 결과가 비극적인 경우를 Hard Real Time System 이라고 하고, DVD 재생에서 버퍼링이 걸리는 등 비극적이지 않은 경우를 Soft Real Time System 이라고 한다.
    - RTOS 가 가져야 할 특징은 1) 선점형 방식 2) 우선순위 스케쥴링 지원 3) 인러럽트 지연이 일정해야 한다는 것이다.
    - 우리가 흔히 쓰는 리눅스나 윈도우즈는 RTOS 가 아닌데, 그 이유는 커널 코드가 선점성을 지원하지 못하기 때문이다.
    - 세그먼테이션(Segmentation) 이란 페이징과 달리 프로세스의 논리적 구성에 따라 구획을 나누는 것이다. 장점으로는 논리적으로 구분해서 프로그래밍하기 용이하며, 메모리 사용 용도에 제약을 둘 수 있다는 것이다.
    - 페이징과 세그먼테이션 기법을 합하여 사용하는 방법은 위키 등의 자료를 참고할 것.
