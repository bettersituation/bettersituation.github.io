---
layout: post
topic: computer-science
title: 운영체제
---

이전 책을 읽으면서 우리가 프로그래밍 하는 모든 것은 운영체제 위에서 실행됨을 알게 되었다.  
그래서 운영체제에 대해 보다 더 알고 싶은 마음이 생겨 운영체제를 다루는 책을 한 권 읽어보았다.  
내가 읽은 책은 Operating System Concepts 으로 소위 공룡책으로 알려진 유명한 책이다.  
읽었다고 하기도 민망할만큼 겉핥기 식으로 읽었지만 그래도 리뷰를 남겨본다.  
글은 목차 별로 나누어 작성한다.  


#### 1장) 서론
    - 운영체제를 바라보는 관점 및 구분과 기초적인 지식을 설명한다. 패스
    
#### 2장) 시스템 구조
    - 운영체제의 대표적인 서비스로 사용자 인터페이스, 프로그램 실행, 입출력 연산, 파일 시스템 조작, 통신, 오류탐지, 
    자원 할당, 자원 관리, 보호 및 보안 등이 있다.  
    - 운영체제를 설계할 때 가장 중요한 원칙 중 하나가 바로 메커니즘과 정책을 분리하는 것이다. 매커니즘은 범용적인 것이 선호된다.  
    - 운영체제는 주로 C/C++ 과 같은 고급언어로 작성되어 있는데, 자주 제기되던 단점은 속도가 느리다는 것이다. 
    그러나 컴퓨터 사양 향상으로 이는 더 이상 문제가 아니다.
    - 운영체제의 구조로는 간단한 구조, 계층적 구조, 마이크로 커널, 모듈 구조 등이 있다.  
    - 간단한 구조는 초기 OS 에서 많이 나타난다. 기능이 예상 범위보다 추가됨에 따라 품질이 저하되는 현상이 있다.  
    - 계층적 구조는 각 층이 직전 층의 API 만을 사용하여 구현된다. 
    어려운 점 중 하나는 각 층마다의 적절한 정의 및 추상화이며, 속도가 느릴 수 있는 단점이 있다.  
    - 마이크로 커널은 최소한의 동작만을 커널 모드로 수행하고, 그 외의 동작은 사용자 공간에서 수행하도록 하는 것이다.
    확장은 용이하지만 가중된 시스템 동작 때문에 오버헤드가 발생하여 성능이 감소한다.  
    - 모듈 구조는 Linux 및 Max OS X 등에서 사용하는 구조로 각 기능을 모듈화하여 구현한다.  
    - 가상기계의 기본적인 아이디어는 한 컴퓨터의 하드웨어를 추상화하여 다수의 다른 실행환경을 제공하는 것이다.  
    - 대표적인 가상기계로는 VMWare, JVM(Java Virtual Machine) 등이 있다.  
    - 커널 고장은 종종 충돌(Crash)라고 불리고, 충돌 덤프에 저장된다.  
    - 컴퓨터가 전원이 켜지면 명령 레지스터는 미리 지정된 메모리 위치를 가리킨다. 이 위치에 운영체제를 로드하기 위한
    매우 작은 부트스트랩 로더가 존재하고, 해당 로더가 실행되며 운영체제가 실행된다.  
    
#### 3장) 프로세스
    - 프로세스 상태는 new(생성 중), running, waiting, ready, terminated 로 나뉜다.
    ready 는 모든 준비가 되어 실행 준비 직전의 상태를 뜻하고 waiting 은 I/O 등에 의하여 대기하고 있는 상태를 뜻한다.
    - 각 프로세스는 PCB(Process Control Block) 에 의해 표현된다.
    PCB의 정보로는 프로세스 상태, 번호, 프로그램 카운터, open file 리스트, 스케쥴링 정보, 메모리 및 레지스터 관련 정보 등이 있다.
    프로세스 카운터는 프로세스가 다음에 실행할 명령어의 주소를 나타낸다.
    - 스레드란 프로세스 내에서의 태스크를 나눠 각각의 태스크가 동시에 수행할 수 있도록 하는 태스크의 개념이다.
    - 스케쥴러는 프로세스의 실행 순서를 결정하기 위해 필요하며 장기, 중기, 단기로 나뉜다. 대부분의 현대 OS 는 단기~중기 스케쥴러를 사용한다.  
    - 문맥 교환(Context Switching) 이란 현재 프로세스의 상태를 저장하고 다른 프로세스를 실행하는 것을 말한다.
    문맥 교환 시간 동안 CPU 는 아무 것도 하지 못하기 때문에 이는 순수한 오버헤드이며, 문맥 교환 시간은 하드웨어 자원에 크게 의존한다.  
    - 프로세스에 대한 대표적 연산으로 생성과 종료가 있다.
    - 프로세스 간 통신(IPC, Interprocess Communication) 를 구성하는 이유로는 정보 공유, 계산 가속화, 모듈성, 편의성 등이 있다.
    구현 방법으로 크게 공유 메모리 사용과 메시징 전달 방법이 있다.
    - 공유 메모리의 경우 유한 버퍼와 무한 버퍼 이슈가 있다. 유한 버퍼일 경우 생산자는 소비자가 소비할 때까지 생산하지 않는다.
    - 메시징 전달 방법은 간접/직접, 동기식/비동기식, 자동/명시적 버퍼링으로 나뉜다.
    - 간접 통신에서 메시지는 port 로 송신되어 소비된다. 
    - 동기식/비동기식은 봉쇄형/비봉쇄형이라고도 표현되며 메시지 송신 수신에 따라 동기식/비동기식으로 처리하는지에 대한 이슈이다.
    - 버퍼는 무용량(이 경우 수신자가 메시지를 수신할 때까지 기다려야 함), 유한 용량, 무한 용량으로 나뉜다.
    - IPC 기법을 활용하여 클라이언트-서버 시스템의 통신에도 사용할 수 있다. 통신 전략은 크게 소켓, RPC 및 파이프 통신으로 나뉜다.
    - 소켓 통신은 양측의 주소와 포트 번호를 필요로 한다. telnet, http, ftp 등 서비스를 구현하는 서버는 특정 포트로부터 메시지를 기다리고 있는 것이다.
    소켓은 다시 TCP(연결 기반 소켓)와 UDP(비연결성 소켓)으로 나뉜다.
    - RPC 는 네트워크에 연결되어 있는 두 시스템 사이의 통신에 사용하기 위하여 프로시저 호출을 추상화하기 위한 방편으로 설계되었다.
    - 대부분의 RPC 시스템은 기종 중립적인 데이터 표현 방식을 정의한다. 대표적인 예가 XDR(external data representation) 이다.
    - RPC를 사용하기 위해 포트 번호를 바인딩해야 하는데, 서버의 포트 번호를 확인하기 위하여 
    사전에 전송 포트를 미리 고정하거나 또는  
    미리 정의되어 있는 고정 RPC 포트를 사용해 서비스 사용 포트 정보를 전송하여 바인딩한다. 이를 랑데부용 디먼(Match Maker)라고 한다.
    - 파이프는 양방향/단방향, 반이중/전이중(양방향 동시 전송 가능 유무), 부모-자식 관계 등 필요 유무, 네트워크 통신 유무로 나뉜다.
    
#### 4장) 다중 스레드 프로그래밍
    - 다중 스레드의 장점으로 응답성, 자원 공유, 경제성, 규모 가변셩이 있다.
    - 다중 코어를 잘 활용하기 위하여 설계자는 작업 나누기, 부하의 균형, 데이터 분리, 데이터 종속성, 시험 및 디버깅에 대한 어려움을 극복해야 한다.
    - 사용자가 생성한 다중 스레드 모델은 커널과의 관계도 고려해야 한다. 다대일 모델, 일대일 모델, 다대다 모델이 있다.
    - 다대일 모델의 경우 다중 스레드를 해도 한 번에 하나의 스레드만 커널에 접근할 수 있기 때문에 병렬로 작동할 수 없다.
    - 일대일 모델은 사용자 스레드가 생성될 때마다 커널 스레드가 생성되어야 하므로 그 수가 커지면 오버헤드가 발생한다. 보통 시스템에 의해 지원 스레드 수가 제한된다.
    - 다대다 모델은 위 두가지 단점을 어느정도 해결했다.
    - 다중 스레드를 구현할 때 (1) Fork() 및 Exec() 시스템 호출 (2) 스레드 취소(비동기식/지연 취소) (3) 신호 처리  
    (4) 스레드 풀 (5) 스레드별 데이터 (6) 스케쥴러 액티베이션(다대다 모델 사용 시 사용자 스레드와 커널 스레드를 맵핑하는 방법) 등을 고려해야 한다.  
    - (6) 스케쥴러 액티베이션을 위해 LWP라 불리는 경량 자료구조가 필요하며, 커널이 응용에 특정 사건을 알려주는 것을 업콜이라고 한다.  
    
#### 5장) CPU 스케쥴링
    - CPU 스케쥴링의 목적은 CPU 이용률을 최대화 하는데에 있다.
    - 프로세스는 CPU-입츌력 버스트 사이클(CPU-I/O Burst Cycle) 로 구성되고, 일반적/통계적으로 CPU 버스트 소요 시간은 지수 분포를 따른다.  
    - 비선점 스케쥴링에서는 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료/대기 상태로 전환될 때까지 CPU를 점유한다.
    - 선점 스케쥴링은 공유 자료에 접근하는 데에 비용을 유발한다. 예를 들어 A 가 자료를 수정하다 B가 실행되면 비일관적인 자료가 나타나는데 이를 해결할 방법이 필요하다.
    - 디스패처(Dispatcher) 는 CPU 제어를 단기 스케쥴러가 선택한 프로세스에 할당한는 모듈이다.
    - 디스패처(Dispatcher) 는 문맥 교환, 사용자 모드 전환, 프로세스 재개 시 특정 위치로 jump 하는 일 등을 한다.  
    - 스케쥴링 기준으로 CPU 이용률, 처리량(단위시간 당 완료 프로세스 개수), 총처리 시간, 대기시간, 응답시간 등이 있다.
    - CPU 스케쥴링으로 선입 선처리 스케쥴링(FCFS, Frist-Come First-Served) 이 쓰일 수 있다.
    모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양보하기 기다리는 것을 호위 효과(Convoy Effect) 라고 한다.  
    - CPU 스케쥴링으로 최단 작업 우선 스케쥴링(SJF, Shortest-Job Frist) 이 쓰일 수 있다.  
    이는 프로세스 전체 길이가 아니라 다음 CPU버스트가 가장 짧은 프로세스에 할당하는 방법이다.  
    실질적으로 CPU 요청 길이를 파악하는 것이 어렵다. 주로 장기 스케쥴링에 쓰인다.  
    단기 스케쥴링에서는 지수평균으로 다음 CPU 버스트 길이를 근사하여 사용한다.  
    - 우선순위 스케쥴링(Priority Scheduling) 은 범용적 스케쥴링으로, SJF 같은 경우 CPU 버스트에 따른 우선순위 스케쥴링이라고 할 수 있다.  
    우선순위 스케쥴링의 문제점은 새롭게 생성되는 프로세스의 우선순위가 기존 프로세스의 우선순위보다 높아 무기한 봉쇄, 다른 말로는 기아 상태에 빠질 수 있다는 점이다.    
    한 가지 해결 방법은 프로세스의 우선순의를 시간이 지남에 따라 점진적으로 높이는 방법이다.  
    - 라운드 로빈 스케쥴링(RR, Round Robin Scheduling) 은 원형 큐로 구현된 준비완료 큐를 돌면서 각 프로세스에 주어진 시간만큼만 CPU를 할당하는 것이다. 시간 할당량에 따라 성능이 좌우된다.  
    - 다단계 큐 스케쥴링(Multilevel Queue Scheduling) 은 준비완료 큐를 별도의 큐로 분류한다. 프로세스 특성에 따라 큐에 종속되며, 각 큐는 자신의 알로리즘에 따라 스케쥴링된다.   
    큐 사이의 스케쥴링은 일반적으로 고정 우선순위의 선점형 스케쥴링으로 구현된다.  
    - 다단계 피드백 큐 스케쥴링(Multilevel Feedback Queue Scheduling) 는 다단계 큐 스케쥴링과 유사하나 프로세스의 우선순위가 바뀔 수 있다는 점이 다르다. 각 프로세스의 CPU 버스트에 따라 큐 사이를 이동한다.
    - 멀티쓰레딩에서 다대다 모델, 다대일 모델을 사용할 경우 프로세스에 속한 사용자 스레드들 사이에서 경쟁이 발생한다. 이른 프로세스 경쟁 범위(Process Contention Scope) 라고 한다.  
    - CPU 상에서 어느 커널 스레드를 스케쥴할 것이지 결정하는 것은 시스템 경쟁 범위(System Contention Scope) 에서 발생하는 것이다.  
    - 다중처리기(Multi-Core 등) 에서 스케쥴링 할 때에 비대칭 다중처리, 대칭 다중처리 방법이 있다.
    - 비대칭 다중처리는 주 서버인 하나의 처리기가 스케쥴링 결정과 입출력 처리, 그리고 다른 시스템 활동을 처리하는 것이다. 구현이 간단하다.  
    - 대칭 다중처리(SMP, Symmetric multiprocessing) 는 공용 준비완료 큐와 사유 준비완료 큐를 갖고 각 처리기가 독자적으로 스케쥴링된다. 두 처리기가 같은 프로세스를 선택하지 않고 프로세스가 사라지지 않는다는 것을 보장해야 한다.  
    - 가장 최근에 접근된 데이터가 캐시를 채우게 된다. 따라서 프로세스를 재시작할 때 이전에 실행한 처리기에서 다시 처리하는 것이 효율적이다. 이러한 성질을 처리기 친화성이라고 한다.  
    노력하지만 보장하지 않을 때를 약한 친화성, 보장되는 경우를 강한 친화성이라고 표현한다.  
    - 부하 균등화(Load balancing)은 SMP 시스템에서 각 처리기의 부하가 고르게 분배되도록 하는 것이다. pull 이주와 push 이주가 있다.  
    Pull 이주는 쉬고 있는 처리기가 바쁜 처리기의 프로세스를 갖고 오는 것이고, Push 이주는 특정 태스크가 각 처리기가 과부화 상태인지 확인하여 과부화 상태인 처리기의 프로세스를 다른 처리기에 이주시키는 것이다.  
    - 스케쥴링 알고리즘 분석 방법으로 특정 시나리오의 결과를 확인하는 결정론적 모델링, 분포를 근사하여 샘플링하는 큐잉 모델, 모의실험 등이 있다.  
    스케쥴링 알고리즘이 안정 상태에 있다면 큐의 길이가 일정할 것이다. 따라서 평균 큐 길이(n) = 평균 도착률(a) * 단위시간 동안 발생한 새로운 프로세스(W) 가 성립한다. 이를 Little's Formula 라고 한다.  
    
#### 6장) 프로세스 동기화
#### 7장) 교착상태
#### 8장) 메모리 관리 전략
#### 9장) 가상 메모리
#### 10장) 파일 시스템
#### 11장) 파일 시스템 구현
#### 12장) 2차 저장장치 구조
#### 13장) 입출력 시스템
#### 14장) 보호
#### 15장) 보안
#### 16장) 분산 운영체제
#### 17장) 분산 파일 시스템
#### 18장) 분산 동기화
#### 19장) 실시간 시스템
#### 20장) 멀티미디어 시스템
#### 21장) Linux 시스템
#### 22장) 윈도우즈 XP
#### 23장) 영향력 있는 운영체제
